<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[八大排序算法]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常见的排序算法 获取随机数组与遍历数组1234567891011121314151617import java.util.Random;public class ArrGet &#123; public int[] getArr(int length,int max)&#123; int[] arr=new int[length]; Random random=new Random(); for (int i=0;i&lt;length;i++)&#123; arr[i]=random.nextInt(max); &#125; return arr; &#125; public void print(int[] arr)&#123; for (int a: arr)&#123; System.out.println(a+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 直接插入排序 直接插入排序是一种简单插入排序，基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程 1234567891011public static void sort(int[] arr)&#123; int length=arr.length; int temp; for (int i=1;i&lt;length;i++)&#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j--)&#123; temp = arr[j]; arr[j]=arr[j-1]; arr[j-1]=temp; &#125; &#125;&#125; 希尔排序 该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序1234567891011121314public static void sort(int[] arr)&#123; int length=arr.length; for (int gap=length/2;gap&gt;0;gap/=2)&#123; for (int i=gap;i&lt;length;i++)&#123; int j=i; int temp; while (j-gap&gt;=0 &amp;&amp; arr[j]&lt;arr[j-gap])&#123; temp = arr[j]; arr[j]=arr[j-gap]; arr[j-gap]=temp; &#125; &#125; &#125;&#125; 简单选择排序 从待排序序列中，找到关键字最小的元素，如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换。从余下的 N - 1 个元素中，找出关键字最小的元素，重复之前的步骤，直到排序结束1234567891011121314151617public static void sort(int[] arr)&#123; int length=arr.length; int temp; for (int i=0;i&lt;length-1;i++)&#123; int min = i; for (int j=i+1;j&lt;length;j++)&#123; if (arr[j]&lt;arr[min])&#123; min = j; &#125; &#125; if (min!=i)&#123; temp = arr[min]; arr[min]=arr[i]; arr[i]=temp; &#125; &#125;&#125; 堆排序 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了12345678910111213141516171819202122232425262728public static void sort(int[] arr)&#123; int length=arr.length; int temp; for (int i=length/2-1;i&gt;=0;i--)&#123; adjustHeap(arr,i,length); &#125; for (int j=length-1;j&gt;0;j--)&#123; temp=arr[0]; arr[0]=arr[j]; arr[j]=temp; adjustHeap(arr,0,j); &#125;&#125;public static void adjustHeap(int[] arr,int i,int length)&#123; int temp=arr[i]; for (int k=i*2+1;k&lt;length;k=k*2+1)&#123; if (k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123; k++; &#125; if (arr[k]&gt;temp)&#123; arr[i] = arr[k]; i=k; &#125;else &#123; break; &#125; &#125; arr[i] = temp;&#125; 冒泡排序 依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成12345678910111213public static void sort(int[] arr)&#123; int length=arr.length; int temp; for (int i=0;i&lt;length-1;i++)&#123; for (int j=0;j&lt;length-1-i;j++)&#123; if (arr[j]&gt;arr[j+1])&#123; temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;&#125; 快速排序(递归) 快速排序是对冒泡排序的一种改进，基本思想是选取一个记录作为枢轴，经过一趟排序，将整段序列分为两个部分，其中一部分的值都小于枢轴，另一部分都大于枢轴。然后继续对这两部分继续进行排序，从而使整个序列达到有序1234567891011121314151617public static void sort(int[] arr,int _left,int _right)&#123; int left=_left; int right=_right; int temp; if (left&lt;=right)&#123; temp=arr[left]; while (left !=right)&#123; while (right&gt;left &amp;&amp; arr[right] &gt;=temp) right--; arr[left] =arr[right]; while (left&lt;right &amp;&amp; arr[left] &lt;=temp) left++; arr[right]=arr[left]; &#125; arr[right] = temp; sort(arr,_left,left-1); sort(arr,right+1,_right); &#125;&#125; 归并排序 归（递归）并（合并）排序采用了分治策略，就是将原问题分解为一些规模较小的相似子问题，然后递归解决这些子问题，最后合并其结果作为原问题的解。归并排序将待排序数组A[1..n]分成两个各含n/2个元素的子序列，然后对这个两个子序列进行递归排序，最后将这两个已排序的子序列进行合并，即得到最终排好序的序列12345678910111213141516171819202122232425262728293031323334public static void sort(int[] arr)&#123; int[] temp=new int[arr.length]; sort(arr,0,arr.length-1,temp);&#125;private static void sort(int[] arr,int left,int right,int[] temp)&#123; if (left&lt;right)&#123; int mid=(left+right)/2; sort(arr,left,mid,temp); sort(arr,mid+1,right,temp); merge(arr,left,mid,right,temp); &#125;&#125;private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123; int i=left; int j=mid+1; int t=0; while (i&lt;=mid &amp;&amp; j&lt;=right)&#123; if (arr[i]&lt;=arr[j])&#123; temp[t++] = arr[i++]; &#125;else &#123; temp[t++] = arr[j++]; &#125; &#125; while (i&lt;=mid)&#123; temp[t++] = arr[i++]; &#125; while (j&lt;=right)&#123; temp[t++] = arr[j++]; &#125; t=0; while (left&lt;=right)&#123; arr[left++] = temp[t++]; &#125;&#125; 基数排序 基数排序是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。1234567891011121314151617181920212223242526272829/** * LSD 从低位向高位 * MSD 从高位向低位 */public static void sort(int[] arr,int max)&#123; int n=1; int k=0; int length=arr.length; int[][] bucket=new int[10][length]; int[] order=new int[length]; while (n&lt;max)&#123; for (int num:arr)&#123; int digit=(num/n)%10; bucket[digit][order[digit]]=num; order[digit]++; &#125; for (int i=0;i&lt;length;i++)&#123; if (order[i]!=0)&#123; for (int j=0;j&lt;order[i];j++)&#123; arr[k]=bucket[i][j]; k++; &#125; &#125; order[i]=0; &#125; n*=10; k=0; &#125;&#125; 性能比较]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象和类]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[面向对象分析方法(OOA) 三大基本特性 1)继承 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为2)封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏3)多态 允许将子类类型的指针赋值给父类类型的指针，实现多态，有二种方式：覆盖，指子类重新定义父类的虚函数的做法；重载，指允许存在多个同名函数，而这些函数的参数表不同 五种设计原则 1)单一职责原则 对一个类而言，应该仅有一个引起它变化的原因，所以应该合理地进行类的职责分配2)开放封闭原则 软件实体应该是可以扩展的，但是不可修改，变化来临时，如果不必改动软件实体裁的源代码，就能扩充它的行为3)Liskov替换原则 子类型必须能够替换掉它们的基类型，通过为每个方法声明”先验条件”和”后验条件”；定义子类时，必须遵守这些”先验条件”和”后验条件”4)依赖倒置原则 抽象不应依赖于细节，细节应该依赖于抽象，思考的过程一般是先抽象后具体，从笼统到细节5)接口隔离原则 多个专用接口优于一个单一的通用接口，一个接口应该保证，实现该接口的实例对象只呈现为单一的角色6)良性依赖原则 不会在实际中造成危害的依赖关系，都是良性依赖，帮助我们抵御”面向对象设计五大原则”以及设计模式的诱惑，以免陷入过度设计的尴尬境地 继承 继承的特性 1)子类拥有父类非private的属性，方法2)子类可以拥有自己的属性和方法，即子类可以对父类进行扩展3)子类可以用自己的方式实现父类的方法4)Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性5)提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系） 继承关键字 extends关键字，在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类implements关键字，使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）super 与 this 关键字，super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类，this关键字：指向自己的引用final关键字，final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 构造器 子类不能继承父类的构造器（构造方法或者构造函数），如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。实例 1234567891011121314151617181920212223242526272829303132333435class SuperClass &#123; private int n; SuperClass()&#123; System.out.println(&quot;SuperClass()&quot;); &#125; SuperClass(int n) &#123; System.out.println(&quot;SuperClass(int n):&quot;+n); this.n = n; &#125;&#125;class SubClass extends SuperClass&#123; private int n; SubClass()&#123; super(300); System.out.println(&quot;SubClass&quot;); &#125; public SubClass(int n)&#123; System.out.println(&quot;SubClass(int n):&quot;+n); this.n = n; &#125;&#125;public class TestSuperSub&#123; public static void main (String args[])&#123; SubClass sc = new SubClass(); SubClass sc2 = new SubClass(200); &#125;&#125; 输出结果为SuperClass(int n):300SubClass()SuperClass()SubClass(int n):200 封装 封装的优点 1)良好的封装能够减少耦合2)类内部的结构可以自由修改3)可以对成员变量进行更精确的控制4)隐藏信息，实现细节 实现封装 修改属性的可见性来限制对属性的访问（一般限制为private）对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问采用 this 关键字是解决实例变量和局部变量之间发生的同名的冲突实例 1234567891011public class EncapTest&#123; private String name; public String getName()&#123; return name; &#125; public void setName(String newName)&#123; name = newName; &#125;&#125;任何要访问类中私有成员变量的类都要通过getter和setter方法 多态 多态的优点 1)消除类型之间的耦合关系2)可替换性3)可扩充性4) 接口性5)灵活性6)简化性 多态存在的三个必要条件 继承重写父类引用指向子类对象当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理 虚方法 当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法，要想调用父类中被重写的方法，则必须使用关键字superJava类在继承中，在上转型中，Java类对象实际调用的方法是子类重写的方法，也就是编译器和jvm调用的不是同一个类的方法Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型 重写(Override)与重载(Overload) 重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常 方法的重写规则 1)参数列表必须完全与被重写方法的相同2)返回类型必须完全与被重写方法的返回类型相同3)访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明protected4)父类的成员方法只能被它的子类重写5)声明为final的方法不能被重写6)声明为static的方法不能被重写，但是能够被再次声明7)子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法8)子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法9)重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。10)构造方法不能被重写11)如果不能继承一个方法，则不能重写这个方法当需要在子类中调用父类的被重写方法时，要使用super关键字 重载(Overload) 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表最常用的地方就是构造器的重载 重载规则 1)被重载的方法必须改变参数列表(参数个数或类型不一样)2)被重载的方法可以改变返回类型3)被重载的方法可以改变访问修饰符4)被重载的方法可以声明新的或更广的检查异常5)方法能够在同一个类中或者在一个子类中被重载6)无法以返回值类型作为重载函数的区分标准 重写与重载之间的区别 table th:nth-of-type(1) { width: 120px; } table th:nth-of-type(2) { width: 120px; } 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式 1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现 值传递和引用传递 区别 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数引用传递就是直接把内存地址传过去，也就是说引用传递时，操作的其实都是源数据，这样的话修改有时候会冲突，需要用逻辑弥补 Java中方法参数传递方式是按值传递 如果参数是基本类型，传递的是基本类型的字面量值的拷贝如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝 抽象类 定义 1)抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象2)抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类3)抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能4)构造方法，类方法（用static修饰的方法）不能声明为抽象方法5)抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类 接口 定义 在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法除非实现接口的类是抽象类，否则该类要定义接口中的所有方法接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象 接口与类相似点 1)一个接口可以有多个方法2)接口文件保存在 .java 结尾的文件中，文件名使用接口名3)接口的字节码文件保存在 .class 结尾的文件中4)接口相应的字节码文件必须在与包名称相匹配的目录结构中 接口与类的区别 1)接口不能用于实例化对象2)接口没有构造方法3)接口中所有的方法必须是抽象方法4)接口不能包含成员变量，除了 static 和 final 变量5)接口不是被类继承了，而是要被类实现6)接口支持多继承 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法 抽象类和接口的区别 1)抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行2)抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。3)接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法4)一个类只能继承一个抽象类，而一个类却可以实现多个接口 重写接口中声明的方法时，需要注意以下规则 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型如果实现接口的类是抽象类，那么就没必要实现该接口的方法 在实现接口的时候，也要注意一些规则 一个类可以同时实现多个接口一个类只能继承一个类，但是能实现多个接口一个接口能继承另一个接口，类的多继承是不合法，但接口允许多继承 标记接口 最常用的继承接口是没有包含任何方法的接口标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的 1)建立一个公共的父接口：正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口2)向一个类添加数据类型：这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组与集合]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[声明数组 1) 一组相同类型(可以是类)数据的有序的集合，声明数组须指明其类型;2) 一个数组是一个对象：意味着数组一类存放于堆中，且必须得 new（创建）出来之后才能使用，所有的对象都具有相同的属性 length;3) 注意声明一个数组并没有创建一个对象;4) 数组能以下列形式声明：int[] i 或 int i[]Car[] c 或 Car c[]注意：C++中只能使用 Car c[]，而在 JAVA 中推荐使用 Car[] c 创建数组：new 1) 创建基本数据类型数组： int[] i = new int[2];2) 创建引用数据类型数组： Car[] c = new Car[100];3) 数组创建后有初始值：数字类型为 0 布尔类型为 false 引用类型为 null4) 边界问题：索引号是以 0 开始的 初始化数组 1) 初始化、创建、和声明分开：1234int[] i;i = new int[2]; //分配（开辟）了两个空间，存放的是对象的引用i[0] = 0;i[1] = 1; 2) 初始化、创建、和声明在同一时间：12int[] i = &#123;0,1&#125;;Car[] c = &#123;new Car(),new Car()&#125;; 多维数组 1) 有效：不对称数组—–&gt;在 java 中允许，但在 c++中是不允许的；1234int[][] i1 = new int[2][3];int[][] i2 = new int[2][];i2[0] = new int[2],i2[1] = new int[3];C++中 int[][] =new int[][3];有效 2) 无效int[][] i1 = new int[][3];3) 高维数组创建必须从低维度向高维度依次序创建。 集合框架体系 集合接口 table th:first-of-type { width: 120px; } 名称 接口描述 Collection 接口 Collection 是最基本的集合接口 ，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象 List 接口 List接口是一个有序的 Collection ，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象 Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。 Set 接口存储一组唯一，无序的对象 SortedSet 继承于Set保存有序的集合 Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射 Map.Entry 描述在一个Map中的一个元素（键/值对）。是一个Map的内部类 SortedMap 继承于 Map，使 Key 保持在升序排列 Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素 Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt; List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 集合实现类（集合类） 类 类描述 LinkedList 该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构， 该类没有同步方法 ，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：Listlist=Collections.synchronizedList(newLinkedList(...)) LinkedList 查找效率低 ArrayList 该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%， 插入删除效率低 Vector 该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度， 默认扩容方式为原来的2倍 HashSet 该类实现了Set接口， 不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个 LinkedHashSet 具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现 TreeSet 该类实现了Set接口，可以实现排序等功能 HashMap HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步 Hashtable Hashtable与HashMap类似， 是HashMap的线程安全版，它支持线程的同步 ，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低 TreeMap 继承了AbstractMap，并且使用一颗树 WeakHashMap 继承AbstractMap类，使用弱密钥的哈希表 LinkedHashMap 继承于HashMap，使用元素的自然顺序对元素进行排序 Vector和ArrayList vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。 如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。 如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。 ArrayList和LinkedList ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 HashMap与TreeMap HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。 在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 HashTable与HashMap 同步性:HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。 HashMap允许存在一个为null的key，多个为null的value 。 HashTable的key和value都不允许为null。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据类型表 Type Bytes Bits Range byte 1B 8位 -128 到 127 short 2B 16位 -2^15 到 2^15-1 int 4B 32位 -2^31 到 2^31-1 long 8B 64位 -2^63 到 2^63-1 float 4B 32位 单精度 double 8B 64位 双精度 char 2B 16位 / boolean / 32位 / ( 黙认整数类型为 int,黙认浮点类型为 double ) 标识符 1) 用以命名类、方法和变量、以及包: 遵守 JAVA 的命名规范；类名的每个单词都以大写字母开头；方法和变量名第一个单词的首字母小写，其他的大写； 2) 以字母、“_”或“$”开头；3）大小写敏感，即大小写严格区分；4) 无长度限制 三种类型的注释： 1）单行注释： // 注释内容2）多行注释： /* 注释内容 */3）文档注释： /** 注释内容 */ 关键字(就是一类已经被启用的标识符) 所有 Java 关键字都是小写英文字符串，不同于 C 语言中的TRUE、FALSE、NULL 等 “goto”（标号：无条件的转向标号所标注的程序位置）and “const”: Java 中不建议使用，在 JAVA 语言里无意义，但是作为关键字保留。c/c++中也不建议使用！ “true” , “false” and “null” ：不属于关键字，属于保留字 内存的逻辑分区 1) 栈区:满足 first in last out（先进后出）的分配原则 —–&gt; 通常存放局部变量(在方法内部定义的变量)2) 堆区:自由存储区c/c++: 动态分配的内存,指针变量；java : 对象3) 代码区:专门用于存放函数的区域。 函数指针：函数在代码区当中的地址 指针函数：函数的返回值为指针类型的函数称为指针函数4) 静态，常量存储区 推荐命名规则1) 类/接口名：单个单词的首字母大写，复合词则每个单词的首字母都大写；2) 方法、变量名：第一个单词首字母小写，其余单词的首字母大写；3) 常量名称：全部字母大写，单词间用“_”连接；4) 包名：全部字母小写。 类与对象 语言层面 实际应用 类 群体 对象（object） 个体 实例（instance） 分配内存空间 实例化 创建对象 成员变量（member variable） 属性（attribute） 成员方法（member method ） 操作（operration） 引用（reference） 唯一标识/地址 引用型变量（reference variable） / 访问修饰符 table th:nth-of-type(1) { width: 100px; } table th:nth-of-type(2) { width: 100px; } table th:nth-of-type(3) { width: 100px; } table th:nth-of-type(4) { width: 100px; } table th:nth-of-type(5) { width: 100px; } 访问权限 类 包 子类 其他包 备注 public ∨ ∨ ∨ ∨ 对任何人都是可用的 protect ∨ ∨ ∨ × 继承的类可以访问以及和private一样的权限 default ∨ ∨ × × 包访问权限，即在整个包内均可被访问 private ∨ × × × 除类型创建者和类型的内部方法之外的任何人都不能访问的元素]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习2]]></title>
    <url>%2F2018%2F06%2F07%2FJava%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[试题2 选择题 1.下列哪项不是有效的标识符？(B) A．中国 B．2testC．$changeD．password注:标识符可以由字母，数字，下划线（），美元（$）组成，但是不能包含@，%，空格等其他的特殊符号，不能以数字开头，不能是Java关键字和保留字 简答题 2.Java中基本数据类型共有哪几种,每种分别占用多少个字节？ java中的基本数据类型共有4类8种,分别为: 整数类型,有byte,short,int,long,分别有1个字节,2个字节,4个字节,8个字节 浮点类型,有float,double,分别有4个字节,8个字节 字符类型,有char,有2个字节 布尔类型,有boolean,有1个字节。 数据类型 字节数 数据类型 字节数 byte 1 short 2 int 4 long 8 float 4 double 8 char 2 boolean 1 3.请简述break，continue以及return的用法以及区别？ break跳出当前循环，继续往下执行 continue 跳出本次循环，继续下一次循环 return 结束当前方法，return之后的语句不会执行 4.请简要说明方法重载和方法重写的区别？ overload（重载） 参数类型、个数、顺序至少有一个不相同。 不能重载只有返回值不同的方法名。 存在于父类和子类、同类中。 override（重写） 方法名、参数、返回值相同。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。 存在于父类和子类之间。 方法被定义为final不能被重写。 分析题 5.分析以下程序的输出结果12345678910111213141516171819public class Polymorphic extends A&#123; public int j=4; public Polymorphic()&#123; print(); &#125; public void print()&#123; System.out.println(j); &#125; public static void main(String[] args) &#123; new Polymorphic(); &#125; &#125; class A&#123; public int i=6; public A()&#123; print(); &#125; public void print()&#123; System.out.print(i); &#125; &#125; 注：父类class A的print方法在子类class Polymorphic中重写，故class A中构造方法执行的是class Polymorphic中的print方法，得到默认输出0，然后执行子类clas Polymorphic中的print方法得到输出4，最后结果为： 0 4 代码题 6.请编程实现数组中的元素按照升序排序冒泡排序：123456789101112131415161718192021public class ArrayTest &#123; public static void bubble(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; for (int a : arr) &#123; System.out.print(a+&quot; &quot;); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; int[] arr=&#123;2,6,3,5,4,1,8,9&#125;; bubble(arr); &#125; &#125; 7.有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，请编程实现,10个月后会有多少只兔子.123456789101112public class Prog1&#123; public static void main(String[] args)&#123; int n = 10; System.out.println(&quot;第&quot;+n+&quot;个月兔子总数为&quot;+fun(n)*2); &#125; private static int fun(int n)&#123; if(n==1 || n==2) return 1; else return fun(n-1)+fun(n-2); &#125; &#125; 8.若一个自然数，恰好与除去它本身以外的一切因数的和相等，这种数叫做完全数。 例如，6=1+2＋3 28=1＋2＋4＋7＋14 496=1+2+4+8＋16+31+62＋124 请计算1000以内的完全数。1234567891011121314151617public class Perfect&#123; public static void main(String[] args)&#123; // 1000以内求完数 for(int i=1;i&lt;1000;i++)&#123; int sum = 0; // 循环求因子,并且累加 for(int j=1;j&lt;=i/2;j++)&#123; if(i%j==0) sum += j; &#125; //判断因子之和是否等于数字本身,要是符合输出 if(sum==i) System.out.print(sum + &quot; &quot;); &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习1]]></title>
    <url>%2F2018%2F05%2F22%2FJava%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[试题 选择题 1.下面 Java 程序的输出结果是( C )1234567public static void main(String[] args)&#123; final int A=4; int a=2; switch(a*2)&#123; case A : System.out.print (a); default : System.out.println(a*2); &#125; &#125; A. 2 B. 4 C. 24 D. 报错 注：无break故会一直执行到最后，case A得到“2”，default得到“4” 2.以下程度最后的输出结果是（ B ）123byte b = Byte.MAX_VALUE;b+=1;System.out.println(b); A.128 B.-128 C.129 D.-129 注：byte，范围在-128~127，通常情况下byte有8位，int有32位，由此可得Byte.MAX_VALUE=127，b+=1 =》128（int类型），超出byte的取值范围，故127写成二进制为：0000（24位）1111111，将128强制类型转换成byte类型的：1000000（其中首位代表符号位也代表值），得到输出结果为：-128 3.设x=1,y=2,z=3,u=false,则表达式u=y&gt;z^x!=z的值是( A )A.true B.false C.0 D.1注：^为异或（当两边相同时取假，不同时取真），表达式可以表示为：u=(y&gt;z)^(x!=z)，左括号判断为false，右括号判断为true，故等号右边为true，赋值给u，最后表达式的值为true 4.运行下面代码输出结果是:( B )12345678910public class Test &#123; public static void main(String[] args) &#123; int a=1,b=2,c=3; int res =(a++)*(++b)*(--c)+(a--)*(--b)*(c++); System.out.println(&quot;res=&quot;+res); System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); System.out.println(&quot;c=&quot;+c); &#125; &#125; A. res=12 a=1 b=1 c=4 B. res=14 a=1 b=2 c=3 C. res=4 a=0 b=3 c=3 D. res=18 a=1 b=3 c=4 注：因为a、b、c都存在++、–两次，所以值不变a=1、b=2、c=3，因此res=132+222=14 5.下面那些关键字不是 JAVA 的关键字 ( B ) A. If B. Then C. Goto D. while 注：123456789101112131415161718访问控制 private protected public类,方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile程序控制 break continue return do while if else for instanceof switch case default 异常处理 try cathc throw throws包相关 import package基本类型 boolean byte char double float int long short null true false变量引用 super this void保留字 goto const 填空题 每个线程都经历(构建 、就绪 、运行 、阻塞和死亡)等5个状态 在java.io包中有4个基本抽象基类:分别是( inputstream , outputstream , Reader , Writer) 类 在java.net包中，IP地址由一个名叫(InetAddress)的特殊的类来描述 RandomAccessFile 类继承Object，并且实现了(DataInput 和 DataOutput)接口 double a=0;a=a/0;则a等于(NaN) stack是(后进先出)的集合,queue是(先进先出)的集合. 在java.awt包中定义了三种界面布局策略，它们分别是：(网状布局 、流式布局 和 边框布局) 简答题 String类和StringBuffer类的主要区别是什么? String类是不可变类，即字符串值一旦初始化后就不可能改变。StringBuffer是可变字符串类，类似String的缓冲区，可以修改字符串的值。StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些 请简述final,finally,finalize的区别? final：用于声明属性、方法和类，表示属性不可变、方法不可覆盖、类不可继承 finally：异常处理语句结构的一部分，表示无论是否出现异常都执行 finalize：Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法 说出ArrayList,Vector, LinkedList的存储性能和特性? ArrayList：使用数组方式存储数据，但是索引数据快而插入数据慢 Vector：使用数组方式存储数据，用了synchronized方法（线程安全），但性能上较ArrayList差 LinkedList：使用双向链表实现存储，插入速度较快，但是索引数据慢 请简述sleep()和wait()有什么区别? sleep：是线程类（Thread）的方法，导致此线程暂停执行指定时间（休息），把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复，时间到了会继续运行，调用sleep不会释放对象锁 wait：是Object类的方法，对象调用wait方法将导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出 notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态 代码题 请使用反射方式动态生成”com.briup.bean.User”类的实例,并通过方法setName设置属性name为tom,通过getName打印输出123456789101112131415161718package com.briup.bean; class User&#123; private String name; public void setName(String name)&#123; this.name=name; &#125; public String getName()&#123; return name; &#125; &#125; public class test&#123; public static void main(String args[])&#123; User user=(User)Class.forName(&quot;com.briup.bean.User&quot;).newInstance(); user.setName(&quot;tom&quot;); System.out.println(user.getName()); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unix]]></title>
    <url>%2F2018%2F05%2F11%2FUnix%2F</url>
    <content type="text"><![CDATA[什么是Unix？ 在 IT 领域，以操作系统而为人所知的 Unix，是 1969 年 AT&amp;T 公司在美国新泽西所开发的(目前它的商标权由国际开放标准组织所拥有)。大多数的操作系统都受到了 Unix 的启发，而 Unix 也受到了未完成的 Multics 系统的启发。Unix 的另一版本是来自贝尔实验室的Play9Unix系统的特点:1.所有数据以纯文本形式存储2.采用单一根文件的树状存储3.单核操作系统，负责低级操作以及由用户发起的操作 Unix常用命令 ls最基本的档案指令。ls 的意义为 “list”，也就是将某一个目录或是某一个档案的内容显示出来cp复制(“COPY”),也就是将一个或多个档案复制成另一个档案或者是将其复制到另一个目录去mv意义为 move,主要是将一档案改名或换至另一个目录rm意义是 remove,也就是用来删除一个档案的指令mkdir让使用者建立一个目录的指令。你可以在一个目录底下使用midir 建立一个子目录chdir(cd)将目前的目录转移到另一个目录去rmdir相对于mkdir,rmdir是用来将一个”空的”目录删除chmod是用来更改档案的存取模式 文件系统权限 权限 文件 目录 r（read） cat 读取文件内容 ls 查看此目录 w (write) 修改文件内容 在此目录下删除，创建文件 x (execute) 执行此文件 cd 进入此目录 Shell scripts:脚本编程 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。.sh 意味着本脚本是用 sh 的语法.csh cshell 的语法.bash bash 的语法注意：95%的脚本是用 sh 写的，比较通用#!/bins/sh (声明本 shell 遵守 bourne shell 的格式)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis]]></title>
    <url>%2F2018%2F05%2F09%2Fmybatis%2F</url>
    <content type="text"><![CDATA[什么是mybatis？ MyBatis 是一款优秀的持久层框架 它支持定制化 SQL、存储过程以及高级映射 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和普通的 Java对象映射成数据库中的记录。 mybatis学习 创建Java项目,命名为mybatis 下载 mybatis,log4j, 并把jar包导入项目 github下载]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle数据库]]></title>
    <url>%2F2018%2F05%2F01%2Foracle%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[认识oracle数据库 一个认知： 认知oracle，是一门数据库 提供产品和服务的厂商：甲骨文 二种概念： 数据库：数据的仓储，存放数据 关系型数据库，数据库中数据对象存在一定的关系 三个名字： sql：以数据库对象为操作对象的语言 sql*plus：用来格式化查询结果，可以编辑交互语句，可以与数据库进行“对话” pl/sql：同样是以数据库对象为操作对象，但由于SQL本身不具备过程控制功能，在SQL中加入诸如循环和选择等面向过程的处理功能 四种分层： 一个Oracle服务器 一个个oracle数据库 一张张的数据表 一条条的数据记录 五种sql分类： 数据查询语句： select 数据操作语句： insert,delete,update 数据定义语句： create,alter,drop, rename,truncate 事物控制的语句： commit,rollback,savepoint 权限有关的语句： grant,revoke DML 数据操纵语言,如insert,delete,update,select(插入、删除、修改、检索)DDL 数据库定义语言 ,如 create,alter,Drop等DCL 数据库控制语言,如grant,deny,revoke等，只有管理员才有这样的权限 oracle基本命令 登录到sql*plus这种工具的方式 sqlplus 用户名/密码 打开运行sql命令行：conn 用户名/密码 查询当前用户下拥有的表：1select table_name from user_tables 模糊查询like %：匹配0个或多个 _：匹配单个字符 dual:虚表 转化成小写：1select LOWER(&apos;SQL Course&apos;) from dual; 转化成大写：1select UPPER(&apos;SQL Course&apos;) from dual; to_char：将数字类型，日期类型转化成字符串 to_number：将字符类型转化为数字类型 to_date：将字符类型转化为日期类型1234select to_char(to_date(&apos;2-mar-2007&apos;),&apos;year-month-dd hh24:mi:ss pm&apos;)from dual; 外连接 左外连接 left join。。。。on 左边多一些(+在右边)：123select *from table1,table2where table1.colum = table2.colum(+) 右外连接 right join…..on 右边多一些(+在左边)：123select *from table1,table2where table1.colum(+) = table2.colum 全外连接 full join….on 两边多一些 集合连接 union:将上下结果取并集，去除掉重复的记录（重复的只显示一次） union all：将上下结果全部显示 minus：取差集 A-B intersect：取交集 组函数 avg()：求平均值 sum()：求和 max()：求最大值 min()：求最小值 count(args)：计数，参数可以是列名、常量、变量 oracle表操作 建表123456CREATE TABLE [schema.]table (column datatype [DEFAULT expr] [column_constraint], ... [table_constraint]); [schema.]：该值就是用户名,如果没有这个，就把该表创建在你登录时候的用户下,高权限用户向底权限用户创建表 DEFAULT expr：如果你插入数据库的数据，该列没有传入任何的值，存入数据库的值就是expr 表级约束 列级约束 联合主键，联合外键，联合唯一必须使用表级约束 非空not null必须使用列级约束 其他的情况，可以使用这两种约束的其中一种 主键的列级约束的格式：12column typedate constraint constraintName constraintType 主键的表级约束的格式: (表级约束位于整个建表语句最后)12constraint constraintName constraintType(column) 非空的列级约束的格式：12column datetype constraint constraintName not null 选择性约束的列级约束：123column datetype constraint constraintName check ( column in(list) ) 唯一性约束的列级约束的格式：12column dateType constraint constraintName unique 唯一性约束的表级约束的格式：12constraint constraintName unique(column) 外键约束的列级约束的格式：123column dateType constraint constraintName referencespktableName(pkcolumn) 外键约束的表级约束的格式：123constraint constraintName foreignkey(column) references pktableName(pkcolumn) 修改表： 添加属性1234ALTER TABLE tableADD (column datatype [DEFAULT expr][NOT NULL] [, column datatype]...); 删除属性12alter table tableNamedrop column columnName 修改属性123alter table tableNamemodify (columnName datatype [default expr][not null]) 增加约束123ALTER TABLE tableNameADD [CONSTRAINT constraint] type (column); 删除约束12alter table 表名drop constraint 约束名 序列：（用来生成主键的值） 创建序列1234567CREATE SEQUENCE name [INCREMENT BY n] [START WITH n] [&#123;MAXVALUE n | NOMAXVALUE&#125;] [&#123;MINVALUE n | NOMINVALUE&#125;] [&#123;CYCLE | NOCYCLE&#125;] [&#123;CACHE n | NOCACHE&#125;] INCREMENT BY n：步长,序列以n增长 start with n:序列的开始值n maxvalue n:最大值 nomaxvalue:没有最大值 minvalue n:最小值 nominvalue :没有最小值 cycle/nocycle:是否循环 cache/nocache:是否使用缓冲区 修改序列123456ALTER SEQUENCE sequence [INCREMENT BY n] [&#123;MAXVALUE n | NOMAXVALUE&#125;] [&#123;MINVALUE n | NOMINVALUE&#125;] [&#123;CYCLE | NOCYCLE&#125;] [&#123;CACHE n | NOCACHE&#125;] 修改序列注意不能修改序列的开始值 删除序列1drop sequence sequenceName 使用序列：12insert into tablenamevalues(s1.nextval,1,&apos;test&apos;); nextval自动生成下一个值 currval自动返回当前值 oracle表数据操作 插入数据1insert into tableName[(column1,column2..)] values(value1,value2..) 更新数据12update tableName set [column=value....]where [] 删除数据12delete [from] tableName[where column=value] delete,truncate: 共同点：都是删除表中的数据，不删除表的结构 不同点：delete可以回滚，DML；truncate不可以回滚，DDL；truncate效率高 s_emp表 id fname lname salary 1 hali tom $1500 2 rose jack $1400 3 ban lily $1620 4 briup milk $1450 5 laye moni $900]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2018%2F01%2F26%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[jdk配置 到当前为止推荐下载JDK8（适用于初学者学习）下载地址 配置jdk其实只用两步： 1.将jdk压缩包解压缩到需要安装的位置2.配置系统环境变量 Linux下： 1.解压jdk8到/usr/lib/jvm下2.编辑/etc/profile文件，添加如下内容：3.编辑~/.bashrc文件，添加如下内容：4.使环境变量生效： source /etc/profilesource ~/.bashrcjava -version 12345#JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161 #解压的jdk8路径export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JAVA_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH Windows下： 1.点击Windows版的jdk8安装包，按提示安装(安装jre出现问题时，断开网络重新安装即可)2.安装好之后，配置环境变量，右键此电脑点击属性，之后点击高级系统设置3.编辑系统变量的Path，加入jdk的bin目录路径与jre的bin目录路径4.打开Windows的命令符窗口，输入： 1java -version]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令小结]]></title>
    <url>%2F2018%2F01%2F20%2FLinux%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Linux命令小结 linux操作系统是一种很简介、方便的语言，使用命令行能够解决很多鼠标困难甚至不能完成的事情 基本的电脑命令 关闭计算机 1shutdown -h now 重启计算机 1reboot 查看Linux系统版本信息 1cat /etc/issue 查看IP 1ifconfig -a 显示当前进程 1top 清屏 1clear 基本的文件处理命令 查看文件内容 1234567cat 由第一行开始显示内容，并将所有内容输出tac 从最后一行倒序显示内容，并将所有内容输出more 根据窗口大小，一页一页的现实文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head 只显示头几行tail 只显示最后几行nl 类似于cat -n，显示时输出行号 创建、复制、移动、删除文件（如操作文件test到目录/home） 1234touch testcp test /homemv test /homerm test /home 创建、复制、移动、删除目录（如操作目录test到目录/home） 1234mkdir testcp -r test /homemv -r test /homerm -r test /home 压缩、解压文件 123456789101112131415.tartar xvf FileName.tar （解包）tar cvf FileName.tar DirName（tar是打包，不是压缩）.gzgunzip FileName.gz（解压）gzip FileName（压缩）.tar.gz 和 .tgztar zxvf FileName.tar.gz（解压）tar zcvf FileName.tar.gz DirName（压缩）.zipunzip FileName.zip（解压）zip FileName.zip DirName（压缩）.rarrar x FileName.rar（解压）rar a FileName.rar DirName（压缩） 修改文件内容、属性及权限（如操作文件test） 1234vim testchgrp users test（修改文件 test 的所属用户组为 users ）chown use test（修改文件 test 的所有者为 use ）chmod 777 test（修改文件test的权限为任何人都有读、写、运行三项权限） 下载、安装、卸载软件 1234(Ubuntu)sudo apt-get install tree 安装treesudo apt-get remove tree 卸载treesudo apt-get update 更新软件]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea破解]]></title>
    <url>%2F2018%2F01%2F20%2FIdea%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Idea破解 最近在使用Idea学习，但是Idea Ultimate版需要收费，根据网上各种各样的破解方法，整理出了最有用的一种破解方法（适用于Windows系统和Linux系统） 需要用到的东西： 安装好的Idea Ultimate版破解补丁：JetbrainsCrack 下载地址 Ubuntu下破解： 下载JetbrainsCrack破解补丁，将破解补丁复制到Idea安装目录的lib目录下： 12cd /home/realliu/下载/sudo cp JetbrainsCrack-2.6.10-release-enc.jar /opt/idea-IU-173.4127.27/lib/ 编辑Idea安装目录的bin目录下的idea.vmoptions文件和idea64.vmoptions文件，在文件末尾添加文本： 12sudo vi /opt/idea-IU-173.4127.27/bin/idea.vmoptions sudo vi /opt/idea-IU-173.4127.27/bin/idea64.vmoptions 然后打开Idea Ultimate版，进入Help里面的Register，在Activation code 中输入： 123456789101112131415161718192021222324ThisCrackLicenseId-&#123; &quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;, &quot;licenseeName&quot;:&quot;idea&quot;, &quot;assigneeName&quot;:&quot;&quot;, &quot;assigneeEmail&quot;:&quot;idea@163.com&quot;, &quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;, &quot;checkConcurrentUse&quot;:false, &quot;products&quot;:[ &#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;, &#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125; ], &quot;hash&quot;:&quot;2911276/0&quot;, &quot;gracePeriodDays&quot;:7, &quot;autoProlongated&quot;:false&#125; 得到以下界面便破解了Idea：]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双系统启动盘制作]]></title>
    <url>%2F2018%2F01%2F20%2F%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[双系统启动盘制作（winPE + Linux 系统启动盘制作） 一直从Windows XP 使用到Windows 10 ，觉得Windows已经可以满足我了，但是最近安装了Linux操作系统之后，发现一样很好用，但是怎么制作U盘启动盘来安装Windows和Linux呢？以下是根据我学的制作得到的一些总结 需要用到的东西: 一个容量不小于4G的U盘（FAT32文件系统）GRUB4DOS双（多）系统引导软件（0.4.4）下载地址Linux操作系统：Ubuntu（16.04.3 LTS）下载地址winPE 镜像 下载地址Windows 操作系统（Windows XP ～Windows 10 系列都可以） 将U盘格式化，文件系统格式为 FAT32，插入并挂载到电脑 下载GRUB4DOS双（多）系统引导软件（0.4.4），进入到下载目录，解压下载的grub4dos-0.4.4-2009-12-03.zip到当前目录，得到文件夹grub4dos-0.4.4： 12cd /home/realliu/下载/unzip grub4dos-0.4.4-2009-12-03.zip 先查看U盘详细信息，进入grub4dos-0.4.4文件夹，将grub4dos-0.4.4安装到U盘中： 123fdisk -lcd grub4dos-0.4.4./bootlace.com (--floppy) /dev/sdc 复制grldr和menu.lst到U盘的根目录： 12cp grldr /media/realliu/B94C-50E0/cp menu.lst /media/realliu/B94C-50E0/ 修改menu.lst，可以参考我的修改： 在U盘根目录新建一个文件夹”Ubuntu”，将Ubuntu（16.04.3 LTS）的镜像和镜像里面casper文件夹下面的initrd.lz,vmlinuz.efi文件拷贝到Ubuntu文件夹 在U盘根目录新建一个文件夹”Windows”，将Windows的镜像拷贝到Windows文件夹 将winPE 镜像拷贝到U盘根目录，双系统启动盘就制作完成了]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2F2017%2F12%2F20%2Fabout-me%2F</url>
    <content type="text"><![CDATA[who am I ? I can tell you i am realliu where are me ? I can tell you i am Chian what are my doing ? I can tell you i am sharing something to you my hobby book my music sunshine my movie no precent 这是一个普通段落： 这是一个代码区块 This is 百度 inline link. This is [百度][id] reference-style link.[id]: https://www.baidu.com/ “baidu” I get 10 times more traffic from Google than fromYahoo or MSN. helloworld helloworld]]></content>
      <categories>
        <category>关于</category>
      </categories>
      <tags>
        <tag>有关</tag>
      </tags>
  </entry>
</search>
